# -*- coding: utf-8 -*-
"""Seminário02.ipynb

#author: Caroline Santos Corrêia

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Za_ZA3UM7WUpWSxfCIhGu8v3lyZroJFs

Seguindo o algoritmo do livro, vamos transformar uma matriz de rotação em um quaternion de rotação, utilizando a seguinte função:
"""

from numpy import * 
import numpy as np
from matplotlib.pyplot import *
import math

def matrixtoquat(M,q):
	
	t = M[0][0]+M[1][1]+M[2][2]
	t = float(t)
	
	if(t >= 0):
		r = sqrt(t+1)
		q.append(r/2)
		q.append((M[2][1]-M[1][2])/(2*r))
		q.append((M[0][2]-M[2][0])/(2*r))
		q.append((M[1][0]-M[0][1])/(2*r))
	
	
	elif((M[0][0] > M[1][1]) and (M[0][0] > M[2][2])):
		r = sqrt(M[0][0]-(M[1][1]+M[2][2]+1))
		q.append((M[2][1]-M[1][2])/(2*r))
		q.append(r/2)
		q.append((M[0][1]-M[1][0])/(2*r))
		q.append((M[2][0]-M[1][2])/(2*r))
	
	elif((M[1][1] > M[0][0]) and (M[1][1] > M[2][2])):
		r = sqrt(M[1][1]-(M[2][2]+M[0][0])+1)
		q.append((M[0][0]-M[2][0])/(2*r))
		q.append((M[0][1]-M[1][0])/(2*r))
		q.append((M[1][2]-M[2][1])/(2*r))
		q.append(r/2)

	else:
		r = sqrt(M[2][2]-(M[0][0]+M[1][2])+1)
		q.append((M[1][0]-M[0][1])/(2*r))
		q.append((M[2][0]-M[0][2])/(2*r))
		q.append((M[1][2]-M[2][1])/(2*r))
		q.append(r/2)
	
	return(q)

"""Agora, recebemos a matriz, chamamos a função e obtemos $q$."""

M = []
q = []

print("Digite a matriz, linha por linha:\n")

for i in range(3):
	C = []
	x,y,z = input().split(' ')
	C.append(float(x))
	C.append(float(y))
	C.append(float(z))
	M.append(C)
	
matrixtoquat(M,q)

print("O quaternion de rotação é:")
print("Parte real: %.2f" % (q[0]))
print("Parte imaginária: (%.2f,%.2f,%.2f)" % (q[1],q[2],q[3]))

"""Agora que já sabemos lidar com os quaternions, vamos, finalmente, determinar a matriz $S$ de atualização do estado de corpos rígidos:

$$
S =  \left(\begin{array}{cccc} \vec{x} \\R \\ \vec{\rho} \\ \vec{L}
    \end{array}\right) \implies S' = \left(\begin{array}{cccc} \vec{v} \\ \vec{\omega}*R \\ \vec{F} \\ \vec{\tau}
    \end{array}\right) 
$$

onde temos $\vec{x}$ a posição do corpo, $R$ para a matriz de orientação, $\vec{\rho}$ para o momento linear e $\vec{L}$ para o momento angular. Assim as respectivas derivadas são as funções $\vec{v}$, de velocidade, $\vec{\omega}*R$, para $R'$, como vimos, $\vec{F}$, de força e $\vec{\tau}$ de torque.

Note que podemos obter todas essas grandezas de $S'$ a partir da própria $S$, assumindo que a massa do corpo é conhecida:

$$
\vec{\omega} = I^{-1}\vec{L},\ \text{por definição de momento angular.}
$$

$$
\vec{v} = \frac{\vec{L}}{m}
$$
"""

from numpy import * 
import numpy as np
from matplotlib.pyplot import *
import math

#funções:

def prod_porescalar(A,x):
	C = [[0 for col in range(3)] for row in range(4)]
	
	for i in range(4):
		for j in range(3):
			C[i][j] = x*A[i][j]
			
	return(C)

def soma_matriz(A,B):
	C = [[0 for col in range(3)] for row in range(4)]
	
	for i in range(4):
		for j in range(3):
			C[i][j] = A[i][j]+B[i][j]
	
	return(C)

def transposta(M):
	X = [[0 for col in range(3)] for row in range(3)]
	for i in range(3):
		for j in range(3):
			X[i][j] = M[j][i]
			
	return(X)
	
def prodmatrizvet(A,x):
	p = []
	
	for i in range(3):
		y = 0
		for j in range(3):
				y += A[i][j]*x[j]
		p.append(y)
				
	return(p)

def normaliza(v):
	v_unitario = []
	
	modulo = math.sqrt(v[0]**2+v[1]**2+v[2]**2)
	
	v_unitario.append((1/modulo)*v[0])
	v_unitario.append((1/modulo)*v[1])
	v_unitario.append((1/modulo)*v[2])
	
	return(v_unitario)

def multiplica_quat(q_1,q_2,arg_1,arg_2):
	q_1vetor = [q_1[1],q_1[2],q_1[3]]
	q_2vetor = [q_2[1],q_2[2],q_2[3]]
	
	r_1 = math.sqrt(q_1[0]**2+q_1[1]**2+q_1[2]**2+q_1[3]**2)
	r_2 = math.sqrt(q_2[0]**2+q_2[1]**2+q_2[2]**2+q_2[3]**2)
	
	r_1 = float(r_1)
	r_2 = float(r_2)
	
	u = [] #os dois quaternions têm a mesma direção, então têm o mesmo vet.unitário
	
	u.append((1/r_1)*q_1vetor[0])
	u.append((1/r_1)*q_1vetor[1])
	u.append((1/r_1)*q_1vetor[2])
	
	q_prod = []
	
	q_prod.append(r_1*r_2*math.cos(arg_1+arg_2))
	
	q_prod.append(math.sin(arg_1+arg_2)*u[0])
	q_prod.append(math.sin(arg_1+arg_2)*u[1])
	q_prod.append(math.sin(arg_1+arg_2)*u[2])
	
	return(q_prod)

def multiplica_matriz(A,B):
	
	C = [[0 for col in range(3)] for row in range(3)]

	for i in range(3):
		for j in range(3):
			for k in range(3):
				C[i][j] += A[i][k]*B[k][j]
				
	return(C)

def quattomatrix(q):
	
	R = [[0 for col in range(3)] for row in range(3)]
	
	R[0][0] = q[0]**2+q[1]**2-q[2]**2-q[3]**2
	R[0][1] = 2*(q[1]*q[2]-q[0]*q[3])
	R[0][2] = 2*(q[1]*q[3]+q[0]*q[2])
	
	R[1][0] = 2*(q[1]*q[2]+q[0]*q[3])
	R[1][1] = q[0]**2-q[1]**2+q[2]**2-q[3]**2
	R[1][2] = 2*(q[1]*q[3]-q[0]*q[1])
	
	R[2][0] = 2*(q[1]*q[3]-q[0]*q[2])
	R[2][1] = 2*(q[2]*q[3]+q[0]*q[1])
	R[2][2] = q[0]**2-q[1]**2-q[2]**2+q[3]**2
	
	return(R)
	
                    #**** FUNÇÃO PRINCIPAL COMEÇA****

def ComputeRigidDerivative(S,m,I_0):
	dS = []

	#obtendo o vetor velocidade:

	p_new = []
	p_new.append(S[2][0]/m)
	p_new.append(S[2][0]/m)
	p_new.append(S[2][0]/m)

	dS.append(p_new)

	#obtendo a matriz inversa do momento de inércia nas coordenadas globais:
	
	print("Quaternion de rotação:")

	q = []
	q_x,q_y,q_z,q_k = input().split()
	q.append(float(q_x))
	q.append(float(q_y))
	q.append(float(q_z))
	q.append(float(q_k))

	#transformando um quaternion numa matriz de orientação:

	R = quattomatrix(q)
	R_transp = transposta(R)

	I = multiplica_matriz(R,I_0) 
	I_inv = multiplica_matriz(I,R_transp)

	for i in range(3):
		for j in range(3):
			I[i][j] = float(I[i][j])

	#obtendo a velocidade angular:
	omega = prodmatrizvet(I_inv,S[3]) 

	#transformando o vetor omega em um quaternion:

	omega_q = [0,omega[0],omega[1],omega[2]]

	#obtendo a derivada do quaternion:

	print("Argumento do quaternion de rotação:")
	arg_q = input()
	arg_q = float(arg_q)
	print("Argumento do quaternion de omega:")
	arg_omega = input()
	arg_omega = float(arg_omega)

	dq = multiplica_quat(omega_q,q,arg_q,arg_omega)

	dq[1] = 0.5*dq[1]
	dq[2] = 0.5*dq[2]
	dq[3] = 0.5*dq[3]

	dq_puro = [dq[1],dq[2],dq[3]]

	dS.append(dq_puro)

	#criando o vetor da força resultante(derivada de p):

	F = []
	F.append(float(0))
	F.append(float(0))
	F.append(float(0))

	dl = []
	dl.append(float(0))
	dl.append(float(0))
	dl.append(float(0))

	print("Número de forças aplicadas sobre o corpo(forças externas):")
	n = input()
	n = int(n)

	F = [0,0,0]
	for i in range(n):
		print("Vetor força %d:" % i)
		f_x,f_y,f_z = input().split(' ')
		f_x = float(f_x)
		f_y = float(f_y)
		f_z = float(f_z)
	
		F[0] += f_x
		F[1] += f_y
		F[2] += f_z
	
		#calculando o torque gerado por cada força externa a partir do ponto de 
		#aplicação
		print("Ponto de aplicação da força:")
		pt_x,pt_y,pt_z = input().split(' ')
		pt_x = float(pt_x)
		pt_y = float(pt_y)
		pt_z = float(pt_z)
		r = []
		r.append(pt_x-x[0])
		r.append(pt_y-x[1])
		r.append(pt_z-x[2])
	
		dl[0] += np.cross(r,F)[0]
		dl[1] += np.cross(r,F)[1]
		dl[2] += np.cross(r,F)[2]
	
	dS.append(F)
	dS.append(dl)
	
	return(dS)
	
	                #**** FUNÇÃO PRINCIPAL TERMINA ****
	
#recebendo dados do corpo:

print("Massa do corpo:")
m = input()
m = float(m)

print("Matriz inversa do momento de inércia:")

I_0 = [[0 for col in range(3)] for row in range(3)]

for i in range(3):
		I_0[i][0],I_0[i][1],I_0[i][2] = input().split(' ')

for i in range(3):
	for j in range(3):
		I_0[i][j] = float(I_0[i][j])
		
print("Quaternion de rotação:")

q = []
q_x,q_y,q_z,q_k = input().split()
q.append(float(q_x))
q.append(float(q_y))
q.append(float(q_z))
q.append(float(q_k))

#transformando um quaternion numa matriz de orientação:

R = quattomatrix(q)
for i in range(3):
	for j in range(3):
		R[i][j] = float(R[i][j])

#criando a matriz do estado original do corpo

S = []

print("Vetor posição:")
x=[]
x_x,x_y,x_z = input().split(' ')
x.append(float(x_x))
x.append(float(x_y))
x.append(float(x_z))
S.append(x)

q_puro = [0,q[1],q[2],q[3]]
q_vetor = [q[1],q[2],q[3]]

S.append(q_vetor)

print("Momento linear:")
p = []
p_x,p_y,p_z = input().split(' ')
p.append(float(p_x))
p.append(float(p_y))
p.append(float(p_z))
S.append(p)

print("Momento angular:")
l = []
l_x,l_y,l_z = input().split(' ')
l.append(float(l_x))
l.append(float(l_y))
l.append(float(l_z))
S.append(l)

#criando a matriz derivada do estado do corpo(ISSO AQUI NA FUNÇÃO PRINCIPAL)

print("Matriz do estado original do corpo:")
for i in range(4):
	print(S[i])

dS = ComputeRigidDerivative(S,m,I_0)
print("Matriz derivada do estado do corpo:")
for i in range(4):
	print(dS[i])
